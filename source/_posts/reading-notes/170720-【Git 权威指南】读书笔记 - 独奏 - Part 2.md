---
title: 【Git 权威指南】读书笔记 - 独奏 - Part 2
permalink: got-git-reading-notes-solo-part2
date: 2017-07-20 11:00:00
comments: true
toc: true
tags:
   - git
   - reading-notes
description:
---

主要内容：【Git 对象】

什么是 `HEAD`？什么是 `master`？为什么它们二者（在上一章）可以相互替换使用？为什么 Git 中的很多对象像提交、树、文件内容等都用 40 位的 `SHA1` 哈希值来表示？

## Git 对象
### Git 对象库探秘
40 位十六进制数字组成的 `SHA1` 哈希值
``` bash
$ git log -1 --pretty=raw
# 这是本次提交的唯一标识。
commit e695606fc5e31b2ff9038a48a3d363f4c21a3d86
# 这是本次提交所对应的目录树。
tree f58da9a820e3fd9d84ab2ca2f1b467ac265038f9
# 这是本地提交的父提交（上一次提交）。
parent a0c641e92b10d8bcca1ed1bf84ca80340fdefee6
author Jiang Xin <jiangxin@ossxp.com> 1291022581 +0800
committer Jiang Xin <jiangxin@ossxp.com> 1291022581 +0800

    which version checked in?
```

研究 Git 对象 ID 的命令是 `git cat-file`，用下面的命令可以查看一下这三个 ID 的类型。
``` bash
$ git cat-file -t e695606
commit
$ git cat-file -t f58d
tree
$ git cat-file -t fd3c06
blob
```

<!-- more -->

再用 `git cat-file` 命令查看一下这几个对象的内容。对于 `blob` 对象，这个对象保存着文件 welcome.txt 的内容。
``` bash
$ git cat-file -p fd3c06
Hello.
Nice to meet you.
```

这个写对象都存在 Git 库中的 `objects` 目录下，ID 的前两位作为目录名，后 38 位作为文件名。
``` bash
$ for id in e695606 f58da9a a0c641e fd3c069; do \
  ls .git/objects/${id:0:2}/${id:2}*; done
.git/objects/e6/95606fc5e31b2ff9038a48a3d363f4c21a3d86
.git/objects/f5/8da9a820e3fd9d84ab2ca2f1b467ac265038f9
.git/objects/a0/c641e92b10d8bcca1ed1bf84ca80340fdefee6
.git/objects/fd/3c069c1de4f4bc9b15940f490aeb48852f3c42
```

![Git 对象库探秘](/image/2017-07/got-git-reading-notes-solo-git-objects.png)

### HEAD 和 master 的奥秘
``` bash
$ git log -1 HEAD

$ git log -1 master

$ git log -1 refs/heads/master
```
在当前版本库中，`HEAD`、`master` 和 `refs/heads/master` 具有相同的指向。现在到版本库（.git 目录）中一探它们的究竟。

``` bash
$ find .git -name HEAD -o -name master
.git/HEAD
.git/logs/HEAD
.git/logs/refs/heads/master
.git/refs/heads/master
```

显示一下 `.git/HEAD`
``` bash
$ cat .git/HEAD
ref: refs/heads/master
```
指向一个引用：`refs/heads/master`

``` bash
$ cat .git/refs/heads/master
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
```

显示该提交的内容
``` bash
$ git cat-file -p e695606fc5e31b2ff9038a48a3d363f4c21a3d86
tree f58da9a820e3fd9d84ab2ca2f1b467ac265038f9
parent a0c641e92b10d8bcca1ed1bf84ca80340fdefee6
author Jiang Xin <jiangxin@ossxp.com> 1291022581 +0800
committer Jiang Xin <jiangxin@ossxp.com> 1291022581 +0800

which version checked in?
```

原来分支 `master` 指向的是一个提交ID（最新提交）。

这样的分支实现是多么的巧妙啊：既然可以从任何提交开始建立一条历史跟踪链，那么用一个文件指向这个链条的最新提交，那么这个文件就可以用于追踪整个提交历史了。

这个文件就是 `.git/refs/heads/master` 文件。

![HEAD 和 master 的奥秘](/image/2017-07/got-git-reading-notes-solo-git-repos-detail.png)

目录 `.git/refs` 是保存引用的命名空间，其中 `.git/refs/heads` 目录下的引用又称为分支。对于分支既可以使用正规的长格式的表示法，如 `refs/heads/master`，也可以去掉前面的两级目录用 `master` 来表示。Git 有一个底层命令 `git rev-parse` 可以用于显示引用对应的提交 ID。

### 问题：SHA1哈希值到底是什么，如何生成的？
哈希(hash)是一种数据摘要算法（或称散列算法），是信息安全领域当中重要的理论基石。该算法将任意长度的输入经过散列运算转换为固定长度的输出。固定长度的输出可以称为对应的输入的数字摘要或哈希值。

``` bash
$ echo -n Git |sha1sum
5819778898df55e3a762f0c5728b457970d72cae  -
```

提交的 SHA1 哈希值生成方法：
``` bash
$ git cat-file commit HEAD | wc -c
234

# 在提交信息的前面加上内容 `commit 234<null>`（`<null>`为空字符），然后执行 SHA1 哈希算法。
$ ( printf "commit 234\000"; git cat-file commit HEAD ) | sha1sum
e695606fc5e31b2ff9038a48a3d363f4c21a3d86  -

# 上面命令得到的哈希值和用 `git rev-parse` 看到的是一样的。
$ git rev-parse HEAD
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
```

文件内容的 SHA1 哈希值生成方法：
``` bash
# 文件总共包含 25 字节的内容。
$ git cat-file blob HEAD:welcome.txt | wc -c
25

# 在文件内容的前面加上blob 25<null>的内容，然后执行SHA1哈希算法。
$ ( printf "blob 25\000"; git cat-file blob HEAD:welcome.txt ) | sha1sum
fd3c069c1de4f4bc9b15940f490aeb48852f3c42  -

# 上面命令得到的哈希值和用git rev-parse看到的是一样的。
$ git rev-parse HEAD:welcome.txt
fd3c069c1de4f4bc9b15940f490aeb48852f3c42
```

树的SHA1哈希值的形成方法：
``` bash
# HEAD对应的树的内容共包含39个字节。
$ git cat-file tree HEAD^{tree} | wc -c
39

# 在树的内容的前面加上tree 39<null>的内容，然后执行SHA1哈希算法。
$ ( printf "tree 39\000"; git cat-file tree HEAD^{tree} ) | sha1sum
f58da9a820e3fd9d84ab2ca2f1b467ac265038f9  -

# 上面命令得到的哈希值和用git rev-parse看到的是一样的。
$ git rev-parse HEAD^{tree}
f58da9a820e3fd9d84ab2ca2f1b467ac265038f9
```

### 问题：为什么不用顺序的数字来表示提交？
集中式版本控制系统因为只有一个集中式的版本库，可以很容易的实现依次递增的全局唯一的提交号。Git作为分布式版本控制系统，开发可以是非线性的。这就要求提交的编号不能仅仅是本地局部有效，而是要“全球唯一”。

采用部分的 SHA1 哈希值。不必写全 40 位的哈希值，只采用开头的部分，不和现有其他的冲突即可。

使用 `master` 代表分支 `master` 中最新的提交，使用全称 `refs/heads/master` 亦可。

使用 `HEAD` 代表版本库中最近的一次提交。

符号 `^` 可以用于指代父提交。例如：
- `HEAD^` 代表版本库中上一次提交，即最近一次提交的父提交。
- `HEAD^^` 则代表 `HEAD^` 的父提交。

对于一个提交有多个父提交，可以在符号 `^` 后面用数字表示是第几个父提交。例如：
- `a573106^2` 含义是提交 `a573106` 的多个父提交中的第二个父提交。
- `HEAD^1` 相当于 `HEAD^` 含义是 HEAD 多个父提交中的第一个。
- `HEAD^^2` 含义是 `HEAD^`（HEAD父提交）的多个父提交中的第二个。

符号 `~<n>` 也可以用于指代祖先提交。效果等同：
``` bash
a573106~5
a573106^^^^^
```

提交所对应的树对象：`a573106^{tree}`

某一此提交对应的文件对象：`a573106:path/to/file`

暂存区中的文件对象：`:path/to/file`

```
$ git rev-parse HEAD
$ git cat-file -p e695
$ git cat-file -p e695^
$ git rev-parse e695^{tree}
```

> Reference:
> - [2. Git独奏 &mdash; GotGit](http://www.worldhello.net/gotgit/02-git-solo/index.html)
