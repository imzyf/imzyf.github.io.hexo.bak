---
title: 【Git 权威指南】读书笔记 - 独奏 - Part 2
permalink: got-git-reading-notes-solo-part2
date: 2017-07-20 11:00:00
comments: true
toc: true
tags:
   - git
   - reading-notes
description:
---

主要内容：【Git 对象】、【Git 重置】

什么是 `HEAD`？什么是 `master`？为什么它们二者（在上一章）可以相互替换使用？为什么 Git 中的很多对象像提交、树、文件内容等都用 40 位的 `SHA1` 哈希值来表示？

## Git 对象
### Git 对象库探秘
40 位十六进制数字组成的 `SHA1` 哈希值
``` bash
$ git log -1 --pretty=raw
# 这是本次提交的唯一标识。
commit e695606fc5e31b2ff9038a48a3d363f4c21a3d86
# 这是本次提交所对应的目录树。
tree f58da9a820e3fd9d84ab2ca2f1b467ac265038f9
# 这是本地提交的父提交（上一次提交）。
parent a0c641e92b10d8bcca1ed1bf84ca80340fdefee6
author Jiang Xin <jiangxin@ossxp.com> 1291022581 +0800
committer Jiang Xin <jiangxin@ossxp.com> 1291022581 +0800

    which version checked in?
```

研究 Git 对象 ID 的命令是 `git cat-file`，用下面的命令可以查看一下这三个 ID 的类型。
``` bash
$ git cat-file -t e695606
commit
$ git cat-file -t f58d
tree
$ git cat-file -t fd3c06
blob
```

<!-- more -->

再用 `git cat-file` 命令查看一下这几个对象的内容。对于 `blob` 对象，这个对象保存着文件 welcome.txt 的内容。
``` bash
$ git cat-file -p fd3c06
Hello.
Nice to meet you.
```

这个写对象都存在 Git 库中的 `objects` 目录下，ID 的前两位作为目录名，后 38 位作为文件名。
``` bash
$ for id in e695606 f58da9a a0c641e fd3c069; do \
  ls .git/objects/${id:0:2}/${id:2}*; done
.git/objects/e6/95606fc5e31b2ff9038a48a3d363f4c21a3d86
.git/objects/f5/8da9a820e3fd9d84ab2ca2f1b467ac265038f9
.git/objects/a0/c641e92b10d8bcca1ed1bf84ca80340fdefee6
.git/objects/fd/3c069c1de4f4bc9b15940f490aeb48852f3c42
```

![Git 对象库探秘](/image/2017-07/got-git-reading-notes-solo-git-objects.png)

### HEAD 和 master 的奥秘
``` bash
$ git log -1 HEAD

$ git log -1 master

$ git log -1 refs/heads/master
```
在当前版本库中，`HEAD`、`master` 和 `refs/heads/master` 具有相同的指向。现在到版本库（.git 目录）中一探它们的究竟。

``` bash
$ find .git -name HEAD -o -name master
.git/HEAD
.git/logs/HEAD
.git/logs/refs/heads/master
.git/refs/heads/master
```

显示一下 `.git/HEAD`
``` bash
$ cat .git/HEAD
ref: refs/heads/master
```
指向一个引用：`refs/heads/master`

``` bash
$ cat .git/refs/heads/master
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
```

显示该提交的内容
``` bash
$ git cat-file -p e695606fc5e31b2ff9038a48a3d363f4c21a3d86
tree f58da9a820e3fd9d84ab2ca2f1b467ac265038f9
parent a0c641e92b10d8bcca1ed1bf84ca80340fdefee6
author Jiang Xin <jiangxin@ossxp.com> 1291022581 +0800
committer Jiang Xin <jiangxin@ossxp.com> 1291022581 +0800

which version checked in?
```

原来分支 `master` 指向的是一个提交ID（最新提交）。

这样的分支实现是多么的巧妙啊：既然可以从任何提交开始建立一条历史跟踪链，那么用一个文件指向这个链条的最新提交，那么这个文件就可以用于追踪整个提交历史了。

这个文件就是 `.git/refs/heads/master` 文件。

![HEAD 和 master 的奥秘](/image/2017-07/got-git-reading-notes-solo-git-repos-detail.png)

目录 `.git/refs` 是保存引用的命名空间，其中 `.git/refs/heads` 目录下的引用又称为分支。对于分支既可以使用正规的长格式的表示法，如 `refs/heads/master`，也可以去掉前面的两级目录用 `master` 来表示。Git 有一个底层命令 `git rev-parse` 可以用于显示引用对应的提交 ID。

### 问题：SHA1哈希值到底是什么，如何生成的？
哈希(hash)是一种数据摘要算法（或称散列算法），是信息安全领域当中重要的理论基石。该算法将任意长度的输入经过散列运算转换为固定长度的输出。固定长度的输出可以称为对应的输入的数字摘要或哈希值。

``` bash
$ echo -n Git |sha1sum
5819778898df55e3a762f0c5728b457970d72cae  -
```

提交的 SHA1 哈希值生成方法：
``` bash
$ git cat-file commit HEAD | wc -c
234

# 在提交信息的前面加上内容 `commit 234<null>`（`<null>`为空字符），然后执行 SHA1 哈希算法。
$ ( printf "commit 234\000"; git cat-file commit HEAD ) | sha1sum
e695606fc5e31b2ff9038a48a3d363f4c21a3d86  -

# 上面命令得到的哈希值和用 `git rev-parse` 看到的是一样的。
$ git rev-parse HEAD
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
```

文件内容的 SHA1 哈希值生成方法：
``` bash
# 文件总共包含 25 字节的内容。
$ git cat-file blob HEAD:welcome.txt | wc -c
25

# 在文件内容的前面加上blob 25<null>的内容，然后执行SHA1哈希算法。
$ ( printf "blob 25\000"; git cat-file blob HEAD:welcome.txt ) | sha1sum
fd3c069c1de4f4bc9b15940f490aeb48852f3c42  -

# 上面命令得到的哈希值和用git rev-parse看到的是一样的。
$ git rev-parse HEAD:welcome.txt
fd3c069c1de4f4bc9b15940f490aeb48852f3c42
```

树的SHA1哈希值的形成方法：
``` bash
# HEAD对应的树的内容共包含39个字节。
$ git cat-file tree HEAD^{tree} | wc -c
39

# 在树的内容的前面加上tree 39<null>的内容，然后执行SHA1哈希算法。
$ ( printf "tree 39\000"; git cat-file tree HEAD^{tree} ) | sha1sum
f58da9a820e3fd9d84ab2ca2f1b467ac265038f9  -

# 上面命令得到的哈希值和用git rev-parse看到的是一样的。
$ git rev-parse HEAD^{tree}
f58da9a820e3fd9d84ab2ca2f1b467ac265038f9
```

### 问题：为什么不用顺序的数字来表示提交？
集中式版本控制系统因为只有一个集中式的版本库，可以很容易的实现依次递增的全局唯一的提交号。Git作为分布式版本控制系统，开发可以是非线性的。这就要求提交的编号不能仅仅是本地局部有效，而是要“全球唯一”。

采用部分的 SHA1 哈希值。不必写全 40 位的哈希值，只采用开头的部分，不和现有其他的冲突即可。

使用 `master` 代表分支 `master` 中最新的提交，使用全称 `refs/heads/master` 亦可。

使用 `HEAD` 代表版本库中最近的一次提交。

符号 `^` 可以用于指代父提交。例如：
- `HEAD^` 代表版本库中上一次提交，即最近一次提交的父提交。
- `HEAD^^` 则代表 `HEAD^` 的父提交。

对于一个提交有多个父提交，可以在符号 `^` 后面用数字表示是第几个父提交。例如：
- `a573106^2` 含义是提交 `a573106` 的多个父提交中的第二个父提交。
- `HEAD^1` 相当于 `HEAD^` 含义是 HEAD 多个父提交中的第一个。
- `HEAD^^2` 含义是 `HEAD^`（HEAD父提交）的多个父提交中的第二个。

符号 `~<n>` 也可以用于指代祖先提交。效果等同：
``` bash
a573106~5
a573106^^^^^
```

提交所对应的树对象：`a573106^{tree}`

某一此提交对应的文件对象：`a573106:path/to/file`

暂存区中的文件对象：`:path/to/file`

```
$ git rev-parse HEAD
$ git cat-file -p e695
$ git cat-file -p e695^
$ git rev-parse e695^{tree}
```

## Git 重置
### 分支游标 master 的探秘
``` bash
$ git log --graph --oneline
* e695606 which version checked in?
* a0c641e who does commit?
* 9e8a761 initialized.
```

引用 `refs/heads/master` 就好像是一个游标，在有新的提交发生的时候指向了新的提交。

Git 提供了 `git reset` 命令，可以将“游标”指向任意一个存在的提交 ID。注意下面的命令中使用了 `--hard` 参数，会破坏工作区未提交的改动，慎用。
``` bash
$ git reset --hard HEAD^
HEAD is now at e695606 which version checked in?
```

### 用 reflog 挽救错误的重置
通过 `.git/logs` 目录下日志文件记录了分支的变更。默认非裸版本库（带有工作区）都提供分支日志功能，这是因为带有工作区的版本库都有如下设置：
``` bash
$ git config core.logallrefupdates
true
```

查看一下 `master` 分支的日志文件 `.git/logs/refs/heads/master` 中的内容。
``` bash
$ tail -5 .git/logs/refs/heads/master
```

Git 提供了一个 `git reflog` 命令，对这个文件进行操作。
``` bash
$ git reflog show master | head -5
9e8a761 master@{0}: 9e8a761: updating HEAD
e695606 master@{1}: HEAD^: updating HEAD
4902dc3 master@{2}: commit: does master follow this new commit?
...
```

重置 master 为两次改变之前的值。
``` bash
$ git reset --hard master@{2}
```

### 深入了解 git reset 命令
``` bash
git reset [-q] [<commit>] [--] <paths>...
git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [<commit>]
```
为了避免路径和引用（或者提交 ID）同名而冲突，可以在 `<paths>` 前用两个连续的短线（减号）作为分隔。

![深入了解 git reset 命令](/image/2017-07/20-got-git-reading-notes-solo-git-reset.png)

- `--hard` 会执行上图中的 1、2、3 全部的三个动作。
 1. 替换引用的指向。引用指向新的提交 ID。
 2. 替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。
 3. 替换工作区。替换后，工作区的内容变得和暂存区一致，也和 HEAD 所指向的目录树内容相同。
- `--soft` 会执行上图中的操作 1。
- `--mixed`（缺省）会执行上图中的操作 1 和操作 2。

``` bash
$ git reset
$ git reset HEAD
# 仅用 HEAD 指向的目录树重置暂存区，工作区不会受到影响，相当于将之前用 git add 命令更新到暂存区的内容撤出暂存区。引用也未改变，因为引用重置到 HEAD 相当于没有重置。

git reset -- filename
git reset HEAD filename
# 仅将文件 filename 撤出暂存区，暂存区中其他文件不改变。相当于对命令 git add filename 的反向操作。

git reset --soft HEAD^
# 工作区和暂存区不改变，但是引用向前回退一次。当对最新提交的提交说明或者提交的更改不满意时，撤销最新的提交以便重新提交。git commit 的反向操作。
# 在之前曾经介绍过一个修补提交命令 git commit --amend，用于对最新的提交进行重新提交以修补错误的提交说明或者错误的提交文件。修补提交命令实际上相当于执行了下面两条命令。（注：文件 .git/COMMIT_EDITMSG 保存了上次的提交日志）
$ git reset --soft HEAD^
$ git commit -e -F .git/COMMIT_EDITMSG

$ git reset HEAD^
# 工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退一次。

$ git reset --hard HEAD^
# 彻底撤销最近的提交。引用回退到前一次，而且工作区和暂存区都会回退到上一次提交的状态。自上一次以来的提交全部丢失。
```

> Reference:
> - [2. Git独奏 &mdash; GotGit](http://www.worldhello.net/gotgit/02-git-solo/index.html)
